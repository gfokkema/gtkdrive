// Copyright 2010 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

// This code was generated by google-apis-code-generator 1.4.1
//   Build date: 2013-08-07 19:00:49 UTC
//   on: 2013-08-12, 19:01:32 UTC
//   C++ generator version:

// ----------------------------------------------------------------------------
// NOTE: This file is generated from Google APIs Discovery Service.
// Service:
//   Drive API (drive/v2)
// Generated from:
//   Version: v2
//   Revision: 93
// Generated by:
//    Tool: google-apis-code-generator 1.4.1
//     C++: 0.1
#ifndef  GOOGLE_DRIVE_API_FILE_H_
#define  GOOGLE_DRIVE_API_FILE_H_

#include <string>
#include "googleapis/base/integral_types.h"
#include "googleapis/base/macros.h"
#include "googleapis/client/data/jsoncpp_data.h"
#include "googleapis/client/util/date_time.h"
#include "googleapis/strings/stringpiece.h"

#include "google/drive_api/parent_reference.h"
#include "google/drive_api/permission.h"
#include "google/drive_api/property.h"
#include "google/drive_api/user.h"

namespace Json {
class Value;
}  // namespace Json

namespace google_drive_api {
using namespace googleapis;

/**
 * The metadata for a file.
 *
 * @ingroup DataObject
 */
class File : public client::JsonCppData {
 public:

  /**
   * Metadata about image media. This will only be present for image types, and
   * its contents will depend on what can be parsed from the image content.
   *
   * @ingroup DataObject
   */
  class FileImageMediaMetadata : public client::JsonCppData {
   public:

    /**
     * Geographic location information stored in the image.
     *
     * @ingroup DataObject
     */
    class FileImageMediaMetadataLocation : public client::JsonCppData {
     public:

      /**
       * Creates a new default instance.
       *
       * @return Ownership is passed back to the caller.
       */
      static FileImageMediaMetadataLocation* New();

      /**
       * Standard constructor for an immutable data object instance.
       *
       * @param[in] storage  The underlying data storage for this instance.
       */
      explicit FileImageMediaMetadataLocation(const Json::Value& storage);

      /**
       * Standard constructor for a mutable data object instance.
       *
       * @param[in] storage  The underlying data storage for this instance.
       */
      explicit FileImageMediaMetadataLocation(Json::Value* storage);

      /**
       * Standard destructor.
       */
      virtual ~FileImageMediaMetadataLocation();

      /**
       * Returns a string denoting the type of this data object.
       *
       * @return <code>google_drive_api::FileImageMediaMetadataLocation</code>
       */
      const StringPiece GetTypeName() const {
        return StringPiece("google_drive_api::FileImageMediaMetadataLocation");
      }

      /**
       * Determine if the '<code>altitude</code>' attribute was set.
       *
       * @return true if the '<code>altitude</code>' attribute was set.
       */
      bool has_altitude() const {
        return Storage().isMember("altitude");
      }

      /**
       * Clears the '<code>altitude</code>' attribute.
       */
      void clear_altitude() {
        MutableStorage()->removeMember("altitude");
      }


      /**
       * Get the value of the '<code>altitude</code>' attribute.
       */
      double get_altitude() const {
        const Json::Value& storage = Storage("altitude");
        return client::JsonValueToCppValueHelper<double>(storage);
      }

      /**
       * Change the '<code>altitude</code>' attribute.
       *
       * The altitude stored in the image.
       *
       * @param[in] value The new value.
       */
      void set_altitude(double value) {
        client::SetJsonValueFromCppValueHelper<double>(
          value, MutableStorage("altitude"));
      }

      /**
       * Determine if the '<code>latitude</code>' attribute was set.
       *
       * @return true if the '<code>latitude</code>' attribute was set.
       */
      bool has_latitude() const {
        return Storage().isMember("latitude");
      }

      /**
       * Clears the '<code>latitude</code>' attribute.
       */
      void clear_latitude() {
        MutableStorage()->removeMember("latitude");
      }


      /**
       * Get the value of the '<code>latitude</code>' attribute.
       */
      double get_latitude() const {
        const Json::Value& storage = Storage("latitude");
        return client::JsonValueToCppValueHelper<double>(storage);
      }

      /**
       * Change the '<code>latitude</code>' attribute.
       *
       * The latitude stored in the image.
       *
       * @param[in] value The new value.
       */
      void set_latitude(double value) {
        client::SetJsonValueFromCppValueHelper<double>(
          value, MutableStorage("latitude"));
      }

      /**
       * Determine if the '<code>longitude</code>' attribute was set.
       *
       * @return true if the '<code>longitude</code>' attribute was set.
       */
      bool has_longitude() const {
        return Storage().isMember("longitude");
      }

      /**
       * Clears the '<code>longitude</code>' attribute.
       */
      void clear_longitude() {
        MutableStorage()->removeMember("longitude");
      }


      /**
       * Get the value of the '<code>longitude</code>' attribute.
       */
      double get_longitude() const {
        const Json::Value& storage = Storage("longitude");
        return client::JsonValueToCppValueHelper<double>(storage);
      }

      /**
       * Change the '<code>longitude</code>' attribute.
       *
       * The longitude stored in the image.
       *
       * @param[in] value The new value.
       */
      void set_longitude(double value) {
        client::SetJsonValueFromCppValueHelper<double>(
          value, MutableStorage("longitude"));
      }

     private:
      void operator=(const FileImageMediaMetadataLocation&);
    };  // FileImageMediaMetadataLocation
    /**
     * Creates a new default instance.
     *
     * @return Ownership is passed back to the caller.
     */
    static FileImageMediaMetadata* New();

    /**
     * Standard constructor for an immutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit FileImageMediaMetadata(const Json::Value& storage);

    /**
     * Standard constructor for a mutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit FileImageMediaMetadata(Json::Value* storage);

    /**
     * Standard destructor.
     */
    virtual ~FileImageMediaMetadata();

    /**
     * Returns a string denoting the type of this data object.
     *
     * @return <code>google_drive_api::FileImageMediaMetadata</code>
     */
    const StringPiece GetTypeName() const {
      return StringPiece("google_drive_api::FileImageMediaMetadata");
    }

    /**
     * Determine if the '<code>aperture</code>' attribute was set.
     *
     * @return true if the '<code>aperture</code>' attribute was set.
     */
    bool has_aperture() const {
      return Storage().isMember("aperture");
    }

    /**
     * Clears the '<code>aperture</code>' attribute.
     */
    void clear_aperture() {
      MutableStorage()->removeMember("aperture");
    }


    /**
     * Get the value of the '<code>aperture</code>' attribute.
     */
    float get_aperture() const {
      const Json::Value& storage = Storage("aperture");
      return client::JsonValueToCppValueHelper<float>(storage);
    }

    /**
     * Change the '<code>aperture</code>' attribute.
     *
     * The aperture used to create the photo (f-number).
     *
     * @param[in] value The new value.
     */
    void set_aperture(float value) {
      client::SetJsonValueFromCppValueHelper<float>(
        value, MutableStorage("aperture"));
    }

    /**
     * Determine if the '<code>cameraMake</code>' attribute was set.
     *
     * @return true if the '<code>cameraMake</code>' attribute was set.
     */
    bool has_cameraMake() const {
      return Storage().isMember("cameraMake");
    }

    /**
     * Clears the '<code>cameraMake</code>' attribute.
     */
    void clear_cameraMake() {
      MutableStorage()->removeMember("cameraMake");
    }


    /**
     * Get the value of the '<code>cameraMake</code>' attribute.
     */
    const StringPiece get_cameraMake() const {
      const Json::Value& v = Storage("cameraMake");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>cameraMake</code>' attribute.
     *
     * The make of the camera used to create the photo.
     *
     * @param[in] value The new value.
     */
    void set_cameraMake(const StringPiece& value) {
      *MutableStorage("cameraMake") = value.data();
    }

    /**
     * Determine if the '<code>cameraModel</code>' attribute was set.
     *
     * @return true if the '<code>cameraModel</code>' attribute was set.
     */
    bool has_cameraModel() const {
      return Storage().isMember("cameraModel");
    }

    /**
     * Clears the '<code>cameraModel</code>' attribute.
     */
    void clear_cameraModel() {
      MutableStorage()->removeMember("cameraModel");
    }


    /**
     * Get the value of the '<code>cameraModel</code>' attribute.
     */
    const StringPiece get_cameraModel() const {
      const Json::Value& v = Storage("cameraModel");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>cameraModel</code>' attribute.
     *
     * The model of the camera used to create the photo.
     *
     * @param[in] value The new value.
     */
    void set_cameraModel(const StringPiece& value) {
      *MutableStorage("cameraModel") = value.data();
    }

    /**
     * Determine if the '<code>colorSpace</code>' attribute was set.
     *
     * @return true if the '<code>colorSpace</code>' attribute was set.
     */
    bool has_colorSpace() const {
      return Storage().isMember("colorSpace");
    }

    /**
     * Clears the '<code>colorSpace</code>' attribute.
     */
    void clear_colorSpace() {
      MutableStorage()->removeMember("colorSpace");
    }


    /**
     * Get the value of the '<code>colorSpace</code>' attribute.
     */
    const StringPiece get_colorSpace() const {
      const Json::Value& v = Storage("colorSpace");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>colorSpace</code>' attribute.
     *
     * The color space of the photo.
     *
     * @param[in] value The new value.
     */
    void set_colorSpace(const StringPiece& value) {
      *MutableStorage("colorSpace") = value.data();
    }

    /**
     * Determine if the '<code>date</code>' attribute was set.
     *
     * @return true if the '<code>date</code>' attribute was set.
     */
    bool has_date() const {
      return Storage().isMember("date");
    }

    /**
     * Clears the '<code>date</code>' attribute.
     */
    void clear_date() {
      MutableStorage()->removeMember("date");
    }


    /**
     * Get the value of the '<code>date</code>' attribute.
     */
    const StringPiece get_date() const {
      const Json::Value& v = Storage("date");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>date</code>' attribute.
     *
     * The date and time the photo was taken (EXIF format timestamp).
     *
     * @param[in] value The new value.
     */
    void set_date(const StringPiece& value) {
      *MutableStorage("date") = value.data();
    }

    /**
     * Determine if the '<code>exposureBias</code>' attribute was set.
     *
     * @return true if the '<code>exposureBias</code>' attribute was set.
     */
    bool has_exposureBias() const {
      return Storage().isMember("exposureBias");
    }

    /**
     * Clears the '<code>exposureBias</code>' attribute.
     */
    void clear_exposureBias() {
      MutableStorage()->removeMember("exposureBias");
    }


    /**
     * Get the value of the '<code>exposureBias</code>' attribute.
     */
    float get_exposureBias() const {
      const Json::Value& storage = Storage("exposureBias");
      return client::JsonValueToCppValueHelper<float>(storage);
    }

    /**
     * Change the '<code>exposureBias</code>' attribute.
     *
     * The exposure bias of the photo (APEX value).
     *
     * @param[in] value The new value.
     */
    void set_exposureBias(float value) {
      client::SetJsonValueFromCppValueHelper<float>(
        value, MutableStorage("exposureBias"));
    }

    /**
     * Determine if the '<code>exposureMode</code>' attribute was set.
     *
     * @return true if the '<code>exposureMode</code>' attribute was set.
     */
    bool has_exposureMode() const {
      return Storage().isMember("exposureMode");
    }

    /**
     * Clears the '<code>exposureMode</code>' attribute.
     */
    void clear_exposureMode() {
      MutableStorage()->removeMember("exposureMode");
    }


    /**
     * Get the value of the '<code>exposureMode</code>' attribute.
     */
    const StringPiece get_exposureMode() const {
      const Json::Value& v = Storage("exposureMode");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>exposureMode</code>' attribute.
     *
     * The exposure mode used to create the photo.
     *
     * @param[in] value The new value.
     */
    void set_exposureMode(const StringPiece& value) {
      *MutableStorage("exposureMode") = value.data();
    }

    /**
     * Determine if the '<code>exposureTime</code>' attribute was set.
     *
     * @return true if the '<code>exposureTime</code>' attribute was set.
     */
    bool has_exposureTime() const {
      return Storage().isMember("exposureTime");
    }

    /**
     * Clears the '<code>exposureTime</code>' attribute.
     */
    void clear_exposureTime() {
      MutableStorage()->removeMember("exposureTime");
    }


    /**
     * Get the value of the '<code>exposureTime</code>' attribute.
     */
    float get_exposureTime() const {
      const Json::Value& storage = Storage("exposureTime");
      return client::JsonValueToCppValueHelper<float>(storage);
    }

    /**
     * Change the '<code>exposureTime</code>' attribute.
     *
     * The length of the exposure, in seconds.
     *
     * @param[in] value The new value.
     */
    void set_exposureTime(float value) {
      client::SetJsonValueFromCppValueHelper<float>(
        value, MutableStorage("exposureTime"));
    }

    /**
     * Determine if the '<code>flashUsed</code>' attribute was set.
     *
     * @return true if the '<code>flashUsed</code>' attribute was set.
     */
    bool has_flashUsed() const {
      return Storage().isMember("flashUsed");
    }

    /**
     * Clears the '<code>flashUsed</code>' attribute.
     */
    void clear_flashUsed() {
      MutableStorage()->removeMember("flashUsed");
    }


    /**
     * Get the value of the '<code>flashUsed</code>' attribute.
     */
    bool get_flashUsed() const {
      const Json::Value& storage = Storage("flashUsed");
      return client::JsonValueToCppValueHelper<bool>(storage);
    }

    /**
     * Change the '<code>flashUsed</code>' attribute.
     *
     * Whether a flash was used to create the photo.
     *
     * @param[in] value The new value.
     */
    void set_flashUsed(bool value) {
      client::SetJsonValueFromCppValueHelper<bool>(
        value, MutableStorage("flashUsed"));
    }

    /**
     * Determine if the '<code>focalLength</code>' attribute was set.
     *
     * @return true if the '<code>focalLength</code>' attribute was set.
     */
    bool has_focalLength() const {
      return Storage().isMember("focalLength");
    }

    /**
     * Clears the '<code>focalLength</code>' attribute.
     */
    void clear_focalLength() {
      MutableStorage()->removeMember("focalLength");
    }


    /**
     * Get the value of the '<code>focalLength</code>' attribute.
     */
    float get_focalLength() const {
      const Json::Value& storage = Storage("focalLength");
      return client::JsonValueToCppValueHelper<float>(storage);
    }

    /**
     * Change the '<code>focalLength</code>' attribute.
     *
     * The focal length used to create the photo, in millimeters.
     *
     * @param[in] value The new value.
     */
    void set_focalLength(float value) {
      client::SetJsonValueFromCppValueHelper<float>(
        value, MutableStorage("focalLength"));
    }

    /**
     * Determine if the '<code>height</code>' attribute was set.
     *
     * @return true if the '<code>height</code>' attribute was set.
     */
    bool has_height() const {
      return Storage().isMember("height");
    }

    /**
     * Clears the '<code>height</code>' attribute.
     */
    void clear_height() {
      MutableStorage()->removeMember("height");
    }


    /**
     * Get the value of the '<code>height</code>' attribute.
     */
    int32 get_height() const {
      const Json::Value& storage = Storage("height");
      return client::JsonValueToCppValueHelper<int32>(storage);
    }

    /**
     * Change the '<code>height</code>' attribute.
     *
     * The height of the image in pixels.
     *
     * @param[in] value The new value.
     */
    void set_height(int32 value) {
      client::SetJsonValueFromCppValueHelper<int32>(
        value, MutableStorage("height"));
    }

    /**
     * Determine if the '<code>isoSpeed</code>' attribute was set.
     *
     * @return true if the '<code>isoSpeed</code>' attribute was set.
     */
    bool has_isoSpeed() const {
      return Storage().isMember("isoSpeed");
    }

    /**
     * Clears the '<code>isoSpeed</code>' attribute.
     */
    void clear_isoSpeed() {
      MutableStorage()->removeMember("isoSpeed");
    }


    /**
     * Get the value of the '<code>isoSpeed</code>' attribute.
     */
    int32 get_isoSpeed() const {
      const Json::Value& storage = Storage("isoSpeed");
      return client::JsonValueToCppValueHelper<int32>(storage);
    }

    /**
     * Change the '<code>isoSpeed</code>' attribute.
     *
     * The ISO speed used to create the photo.
     *
     * @param[in] value The new value.
     */
    void set_isoSpeed(int32 value) {
      client::SetJsonValueFromCppValueHelper<int32>(
        value, MutableStorage("isoSpeed"));
    }

    /**
     * Determine if the '<code>lens</code>' attribute was set.
     *
     * @return true if the '<code>lens</code>' attribute was set.
     */
    bool has_lens() const {
      return Storage().isMember("lens");
    }

    /**
     * Clears the '<code>lens</code>' attribute.
     */
    void clear_lens() {
      MutableStorage()->removeMember("lens");
    }


    /**
     * Get the value of the '<code>lens</code>' attribute.
     */
    const StringPiece get_lens() const {
      const Json::Value& v = Storage("lens");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>lens</code>' attribute.
     *
     * The lens used to create the photo.
     *
     * @param[in] value The new value.
     */
    void set_lens(const StringPiece& value) {
      *MutableStorage("lens") = value.data();
    }

    /**
     * Determine if the '<code>location</code>' attribute was set.
     *
     * @return true if the '<code>location</code>' attribute was set.
     */
    bool has_location() const {
      return Storage().isMember("location");
    }

    /**
     * Clears the '<code>location</code>' attribute.
     */
    void clear_location() {
      MutableStorage()->removeMember("location");
    }


    /**
     * Get a reference to the value of the '<code>location</code>' attribute.
     */
    const FileImageMediaMetadataLocation get_location() const {
      return FileImageMediaMetadataLocation(Storage("location"));
    }

    /**
     * Gets a reference to a mutable value of the '<code>location</code>'
     * property.
     *
     * Geographic location information stored in the image.
     *
     * @return The result can be modified to change the attribute value.
     */
    FileImageMediaMetadataLocation mutable_location() {
      return FileImageMediaMetadataLocation(MutableStorage("location"));
    }

    /**
     * Determine if the '<code>maxApertureValue</code>' attribute was set.
     *
     * @return true if the '<code>maxApertureValue</code>' attribute was set.
     */
    bool has_maxApertureValue() const {
      return Storage().isMember("maxApertureValue");
    }

    /**
     * Clears the '<code>maxApertureValue</code>' attribute.
     */
    void clear_maxApertureValue() {
      MutableStorage()->removeMember("maxApertureValue");
    }


    /**
     * Get the value of the '<code>maxApertureValue</code>' attribute.
     */
    float get_maxApertureValue() const {
      const Json::Value& storage = Storage("maxApertureValue");
      return client::JsonValueToCppValueHelper<float>(storage);
    }

    /**
     * Change the '<code>maxApertureValue</code>' attribute.
     *
     * The smallest f-number of the lens at the focal length used to create the
     * photo (APEX value).
     *
     * @param[in] value The new value.
     */
    void set_maxApertureValue(float value) {
      client::SetJsonValueFromCppValueHelper<float>(
        value, MutableStorage("maxApertureValue"));
    }

    /**
     * Determine if the '<code>meteringMode</code>' attribute was set.
     *
     * @return true if the '<code>meteringMode</code>' attribute was set.
     */
    bool has_meteringMode() const {
      return Storage().isMember("meteringMode");
    }

    /**
     * Clears the '<code>meteringMode</code>' attribute.
     */
    void clear_meteringMode() {
      MutableStorage()->removeMember("meteringMode");
    }


    /**
     * Get the value of the '<code>meteringMode</code>' attribute.
     */
    const StringPiece get_meteringMode() const {
      const Json::Value& v = Storage("meteringMode");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>meteringMode</code>' attribute.
     *
     * The metering mode used to create the photo.
     *
     * @param[in] value The new value.
     */
    void set_meteringMode(const StringPiece& value) {
      *MutableStorage("meteringMode") = value.data();
    }

    /**
     * Determine if the '<code>rotation</code>' attribute was set.
     *
     * @return true if the '<code>rotation</code>' attribute was set.
     */
    bool has_rotation() const {
      return Storage().isMember("rotation");
    }

    /**
     * Clears the '<code>rotation</code>' attribute.
     */
    void clear_rotation() {
      MutableStorage()->removeMember("rotation");
    }


    /**
     * Get the value of the '<code>rotation</code>' attribute.
     */
    int32 get_rotation() const {
      const Json::Value& storage = Storage("rotation");
      return client::JsonValueToCppValueHelper<int32>(storage);
    }

    /**
     * Change the '<code>rotation</code>' attribute.
     *
     * The rotation in clockwise degrees from the image's original orientation.
     *
     * @param[in] value The new value.
     */
    void set_rotation(int32 value) {
      client::SetJsonValueFromCppValueHelper<int32>(
        value, MutableStorage("rotation"));
    }

    /**
     * Determine if the '<code>sensor</code>' attribute was set.
     *
     * @return true if the '<code>sensor</code>' attribute was set.
     */
    bool has_sensor() const {
      return Storage().isMember("sensor");
    }

    /**
     * Clears the '<code>sensor</code>' attribute.
     */
    void clear_sensor() {
      MutableStorage()->removeMember("sensor");
    }


    /**
     * Get the value of the '<code>sensor</code>' attribute.
     */
    const StringPiece get_sensor() const {
      const Json::Value& v = Storage("sensor");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>sensor</code>' attribute.
     *
     * The type of sensor used to create the photo.
     *
     * @param[in] value The new value.
     */
    void set_sensor(const StringPiece& value) {
      *MutableStorage("sensor") = value.data();
    }

    /**
     * Determine if the '<code>subjectDistance</code>' attribute was set.
     *
     * @return true if the '<code>subjectDistance</code>' attribute was set.
     */
    bool has_subjectDistance() const {
      return Storage().isMember("subjectDistance");
    }

    /**
     * Clears the '<code>subjectDistance</code>' attribute.
     */
    void clear_subjectDistance() {
      MutableStorage()->removeMember("subjectDistance");
    }


    /**
     * Get the value of the '<code>subjectDistance</code>' attribute.
     */
    int32 get_subjectDistance() const {
      const Json::Value& storage = Storage("subjectDistance");
      return client::JsonValueToCppValueHelper<int32>(storage);
    }

    /**
     * Change the '<code>subjectDistance</code>' attribute.
     *
     * The distance to the subject of the photo, in meters.
     *
     * @param[in] value The new value.
     */
    void set_subjectDistance(int32 value) {
      client::SetJsonValueFromCppValueHelper<int32>(
        value, MutableStorage("subjectDistance"));
    }

    /**
     * Determine if the '<code>whiteBalance</code>' attribute was set.
     *
     * @return true if the '<code>whiteBalance</code>' attribute was set.
     */
    bool has_whiteBalance() const {
      return Storage().isMember("whiteBalance");
    }

    /**
     * Clears the '<code>whiteBalance</code>' attribute.
     */
    void clear_whiteBalance() {
      MutableStorage()->removeMember("whiteBalance");
    }


    /**
     * Get the value of the '<code>whiteBalance</code>' attribute.
     */
    const StringPiece get_whiteBalance() const {
      const Json::Value& v = Storage("whiteBalance");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>whiteBalance</code>' attribute.
     *
     * The white balance mode used to create the photo.
     *
     * @param[in] value The new value.
     */
    void set_whiteBalance(const StringPiece& value) {
      *MutableStorage("whiteBalance") = value.data();
    }

    /**
     * Determine if the '<code>width</code>' attribute was set.
     *
     * @return true if the '<code>width</code>' attribute was set.
     */
    bool has_width() const {
      return Storage().isMember("width");
    }

    /**
     * Clears the '<code>width</code>' attribute.
     */
    void clear_width() {
      MutableStorage()->removeMember("width");
    }


    /**
     * Get the value of the '<code>width</code>' attribute.
     */
    int32 get_width() const {
      const Json::Value& storage = Storage("width");
      return client::JsonValueToCppValueHelper<int32>(storage);
    }

    /**
     * Change the '<code>width</code>' attribute.
     *
     * The width of the image in pixels.
     *
     * @param[in] value The new value.
     */
    void set_width(int32 value) {
      client::SetJsonValueFromCppValueHelper<int32>(
        value, MutableStorage("width"));
    }

   private:
    void operator=(const FileImageMediaMetadata&);
  };  // FileImageMediaMetadata
  /**
   * Indexable text attributes for the file (can only be written).
   *
   * @ingroup DataObject
   */
  class FileIndexableText : public client::JsonCppData {
   public:

    /**
     * Creates a new default instance.
     *
     * @return Ownership is passed back to the caller.
     */
    static FileIndexableText* New();

    /**
     * Standard constructor for an immutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit FileIndexableText(const Json::Value& storage);

    /**
     * Standard constructor for a mutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit FileIndexableText(Json::Value* storage);

    /**
     * Standard destructor.
     */
    virtual ~FileIndexableText();

    /**
     * Returns a string denoting the type of this data object.
     *
     * @return <code>google_drive_api::FileIndexableText</code>
     */
    const StringPiece GetTypeName() const {
      return StringPiece("google_drive_api::FileIndexableText");
    }

    /**
     * Determine if the '<code>text</code>' attribute was set.
     *
     * @return true if the '<code>text</code>' attribute was set.
     */
    bool has_text() const {
      return Storage().isMember("text");
    }

    /**
     * Clears the '<code>text</code>' attribute.
     */
    void clear_text() {
      MutableStorage()->removeMember("text");
    }


    /**
     * Get the value of the '<code>text</code>' attribute.
     */
    const StringPiece get_text() const {
      const Json::Value& v = Storage("text");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>text</code>' attribute.
     *
     * The text to be indexed for this file.
     *
     * @param[in] value The new value.
     */
    void set_text(const StringPiece& value) {
      *MutableStorage("text") = value.data();
    }

   private:
    void operator=(const FileIndexableText&);
  };  // FileIndexableText
  /**
   * A group of labels for the file.
   *
   * @ingroup DataObject
   */
  class FileLabels : public client::JsonCppData {
   public:

    /**
     * Creates a new default instance.
     *
     * @return Ownership is passed back to the caller.
     */
    static FileLabels* New();

    /**
     * Standard constructor for an immutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit FileLabels(const Json::Value& storage);

    /**
     * Standard constructor for a mutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit FileLabels(Json::Value* storage);

    /**
     * Standard destructor.
     */
    virtual ~FileLabels();

    /**
     * Returns a string denoting the type of this data object.
     *
     * @return <code>google_drive_api::FileLabels</code>
     */
    const StringPiece GetTypeName() const {
      return StringPiece("google_drive_api::FileLabels");
    }

    /**
     * Determine if the '<code>hidden</code>' attribute was set.
     *
     * @return true if the '<code>hidden</code>' attribute was set.
     */
    bool has_hidden() const {
      return Storage().isMember("hidden");
    }

    /**
     * Clears the '<code>hidden</code>' attribute.
     */
    void clear_hidden() {
      MutableStorage()->removeMember("hidden");
    }


    /**
     * Get the value of the '<code>hidden</code>' attribute.
     */
    bool get_hidden() const {
      const Json::Value& storage = Storage("hidden");
      return client::JsonValueToCppValueHelper<bool>(storage);
    }

    /**
     * Change the '<code>hidden</code>' attribute.
     *
     * Whether this file is hidden from the user.
     *
     * @param[in] value The new value.
     */
    void set_hidden(bool value) {
      client::SetJsonValueFromCppValueHelper<bool>(
        value, MutableStorage("hidden"));
    }

    /**
     * Determine if the '<code>restricted</code>' attribute was set.
     *
     * @return true if the '<code>restricted</code>' attribute was set.
     */
    bool has_restricted() const {
      return Storage().isMember("restricted");
    }

    /**
     * Clears the '<code>restricted</code>' attribute.
     */
    void clear_restricted() {
      MutableStorage()->removeMember("restricted");
    }


    /**
     * Get the value of the '<code>restricted</code>' attribute.
     */
    bool get_restricted() const {
      const Json::Value& storage = Storage("restricted");
      return client::JsonValueToCppValueHelper<bool>(storage);
    }

    /**
     * Change the '<code>restricted</code>' attribute.
     *
     * Whether viewers are prevented from downloading this file.
     *
     * @param[in] value The new value.
     */
    void set_restricted(bool value) {
      client::SetJsonValueFromCppValueHelper<bool>(
        value, MutableStorage("restricted"));
    }

    /**
     * Determine if the '<code>starred</code>' attribute was set.
     *
     * @return true if the '<code>starred</code>' attribute was set.
     */
    bool has_starred() const {
      return Storage().isMember("starred");
    }

    /**
     * Clears the '<code>starred</code>' attribute.
     */
    void clear_starred() {
      MutableStorage()->removeMember("starred");
    }


    /**
     * Get the value of the '<code>starred</code>' attribute.
     */
    bool get_starred() const {
      const Json::Value& storage = Storage("starred");
      return client::JsonValueToCppValueHelper<bool>(storage);
    }

    /**
     * Change the '<code>starred</code>' attribute.
     *
     * Whether this file is starred by the user.
     *
     * @param[in] value The new value.
     */
    void set_starred(bool value) {
      client::SetJsonValueFromCppValueHelper<bool>(
        value, MutableStorage("starred"));
    }

    /**
     * Determine if the '<code>trashed</code>' attribute was set.
     *
     * @return true if the '<code>trashed</code>' attribute was set.
     */
    bool has_trashed() const {
      return Storage().isMember("trashed");
    }

    /**
     * Clears the '<code>trashed</code>' attribute.
     */
    void clear_trashed() {
      MutableStorage()->removeMember("trashed");
    }


    /**
     * Get the value of the '<code>trashed</code>' attribute.
     */
    bool get_trashed() const {
      const Json::Value& storage = Storage("trashed");
      return client::JsonValueToCppValueHelper<bool>(storage);
    }

    /**
     * Change the '<code>trashed</code>' attribute.
     *
     * Whether this file has been trashed.
     *
     * @param[in] value The new value.
     */
    void set_trashed(bool value) {
      client::SetJsonValueFromCppValueHelper<bool>(
        value, MutableStorage("trashed"));
    }

    /**
     * Determine if the '<code>viewed</code>' attribute was set.
     *
     * @return true if the '<code>viewed</code>' attribute was set.
     */
    bool has_viewed() const {
      return Storage().isMember("viewed");
    }

    /**
     * Clears the '<code>viewed</code>' attribute.
     */
    void clear_viewed() {
      MutableStorage()->removeMember("viewed");
    }


    /**
     * Get the value of the '<code>viewed</code>' attribute.
     */
    bool get_viewed() const {
      const Json::Value& storage = Storage("viewed");
      return client::JsonValueToCppValueHelper<bool>(storage);
    }

    /**
     * Change the '<code>viewed</code>' attribute.
     *
     * Whether this file has been viewed by this user.
     *
     * @param[in] value The new value.
     */
    void set_viewed(bool value) {
      client::SetJsonValueFromCppValueHelper<bool>(
        value, MutableStorage("viewed"));
    }

   private:
    void operator=(const FileLabels&);
  };  // FileLabels
  /**
   * Thumbnail for the file. Only accepted on upload and for files that are not
   * already thumbnailed by Google.
   *
   * @ingroup DataObject
   */
  class FileThumbnail : public client::JsonCppData {
   public:

    /**
     * Creates a new default instance.
     *
     * @return Ownership is passed back to the caller.
     */
    static FileThumbnail* New();

    /**
     * Standard constructor for an immutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit FileThumbnail(const Json::Value& storage);

    /**
     * Standard constructor for a mutable data object instance.
     *
     * @param[in] storage  The underlying data storage for this instance.
     */
    explicit FileThumbnail(Json::Value* storage);

    /**
     * Standard destructor.
     */
    virtual ~FileThumbnail();

    /**
     * Returns a string denoting the type of this data object.
     *
     * @return <code>google_drive_api::FileThumbnail</code>
     */
    const StringPiece GetTypeName() const {
      return StringPiece("google_drive_api::FileThumbnail");
    }

    /**
     * Determine if the '<code>image</code>' attribute was set.
     *
     * @return true if the '<code>image</code>' attribute was set.
     */
    bool has_image() const {
      return Storage().isMember("image");
    }

    /**
     * Clears the '<code>image</code>' attribute.
     */
    void clear_image() {
      MutableStorage()->removeMember("image");
    }


    /**
     * Get the value of the '<code>image</code>' attribute.
     */
    const StringPiece get_image() const {
      const Json::Value& v = Storage("image");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>image</code>' attribute.
     *
     * The URL-safe Base64 encoded bytes of the thumbnail image.
     *
     * @param[in] value The new value.
     */
    void set_image(const StringPiece& value) {
      *MutableStorage("image") = value.data();
    }

    /**
     * Determine if the '<code>mimeType</code>' attribute was set.
     *
     * @return true if the '<code>mimeType</code>' attribute was set.
     */
    bool has_mimeType() const {
      return Storage().isMember("mimeType");
    }

    /**
     * Clears the '<code>mimeType</code>' attribute.
     */
    void clear_mimeType() {
      MutableStorage()->removeMember("mimeType");
    }


    /**
     * Get the value of the '<code>mimeType</code>' attribute.
     */
    const StringPiece get_mimeType() const {
      const Json::Value& v = Storage("mimeType");
      if (v == Json::Value::null) return StringPiece("");
      return StringPiece(v.asCString());
    }

    /**
     * Change the '<code>mimeType</code>' attribute.
     *
     * The MIME type of the thumbnail.
     *
     * @param[in] value The new value.
     */
    void set_mimeType(const StringPiece& value) {
      *MutableStorage("mimeType") = value.data();
    }

   private:
    void operator=(const FileThumbnail&);
  };  // FileThumbnail
  /**
   * Creates a new default instance.
   *
   * @return Ownership is passed back to the caller.
   */
  static File* New();

  /**
   * Standard constructor for an immutable data object instance.
   *
   * @param[in] storage  The underlying data storage for this instance.
   */
  explicit File(const Json::Value& storage);

  /**
   * Standard constructor for a mutable data object instance.
   *
   * @param[in] storage  The underlying data storage for this instance.
   */
  explicit File(Json::Value* storage);

  /**
   * Standard destructor.
   */
  virtual ~File();

  /**
   * Returns a string denoting the type of this data object.
   *
   * @return <code>google_drive_api::File</code>
   */
  const StringPiece GetTypeName() const {
    return StringPiece("google_drive_api::File");
  }

  /**
   * Determine if the '<code>alternateLink</code>' attribute was set.
   *
   * @return true if the '<code>alternateLink</code>' attribute was set.
   */
  bool has_alternateLink() const {
    return Storage().isMember("alternateLink");
  }

  /**
   * Clears the '<code>alternateLink</code>' attribute.
   */
  void clear_alternateLink() {
    MutableStorage()->removeMember("alternateLink");
  }


  /**
   * Get the value of the '<code>alternateLink</code>' attribute.
   */
  const StringPiece get_alternateLink() const {
    const Json::Value& v = Storage("alternateLink");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>alternateLink</code>' attribute.
   *
   * A link for opening the file in using a relevant Google editor or viewer.
   *
   * @param[in] value The new value.
   */
  void set_alternateLink(const StringPiece& value) {
    *MutableStorage("alternateLink") = value.data();
  }

  /**
   * Determine if the '<code>appDataContents</code>' attribute was set.
   *
   * @return true if the '<code>appDataContents</code>' attribute was set.
   */
  bool has_appDataContents() const {
    return Storage().isMember("appDataContents");
  }

  /**
   * Clears the '<code>appDataContents</code>' attribute.
   */
  void clear_appDataContents() {
    MutableStorage()->removeMember("appDataContents");
  }


  /**
   * Get the value of the '<code>appDataContents</code>' attribute.
   */
  bool get_appDataContents() const {
    const Json::Value& storage = Storage("appDataContents");
    return client::JsonValueToCppValueHelper<bool>(storage);
  }

  /**
   * Change the '<code>appDataContents</code>' attribute.
   *
   * Whether this file is in the appdata folder.
   *
   * @param[in] value The new value.
   */
  void set_appDataContents(bool value) {
    client::SetJsonValueFromCppValueHelper<bool>(
      value, MutableStorage("appDataContents"));
  }

  /**
   * Determine if the '<code>copyable</code>' attribute was set.
   *
   * @return true if the '<code>copyable</code>' attribute was set.
   */
  bool has_copyable() const {
    return Storage().isMember("copyable");
  }

  /**
   * Clears the '<code>copyable</code>' attribute.
   */
  void clear_copyable() {
    MutableStorage()->removeMember("copyable");
  }


  /**
   * Get the value of the '<code>copyable</code>' attribute.
   */
  bool get_copyable() const {
    const Json::Value& storage = Storage("copyable");
    return client::JsonValueToCppValueHelper<bool>(storage);
  }

  /**
   * Change the '<code>copyable</code>' attribute.
   *
   * Whether the file can be copied by the current user.
   *
   * @param[in] value The new value.
   */
  void set_copyable(bool value) {
    client::SetJsonValueFromCppValueHelper<bool>(
      value, MutableStorage("copyable"));
  }

  /**
   * Determine if the '<code>createdDate</code>' attribute was set.
   *
   * @return true if the '<code>createdDate</code>' attribute was set.
   */
  bool has_createdDate() const {
    return Storage().isMember("createdDate");
  }

  /**
   * Clears the '<code>createdDate</code>' attribute.
   */
  void clear_createdDate() {
    MutableStorage()->removeMember("createdDate");
  }


  /**
   * Get the value of the '<code>createdDate</code>' attribute.
   */
  client::DateTime get_createdDate() const {
    const Json::Value& storage = Storage("createdDate");
    return client::JsonValueToCppValueHelper<client::DateTime>(storage);
  }

  /**
   * Change the '<code>createdDate</code>' attribute.
   *
   * Create time for this file (formatted ISO8601 timestamp).
   *
   * @param[in] value The new value.
   */
  void set_createdDate(client::DateTime value) {
    client::SetJsonValueFromCppValueHelper<client::DateTime>(
      value, MutableStorage("createdDate"));
  }

  /**
   * Determine if the '<code>defaultOpenWithLink</code>' attribute was set.
   *
   * @return true if the '<code>defaultOpenWithLink</code>' attribute was set.
   */
  bool has_defaultOpenWithLink() const {
    return Storage().isMember("defaultOpenWithLink");
  }

  /**
   * Clears the '<code>defaultOpenWithLink</code>' attribute.
   */
  void clear_defaultOpenWithLink() {
    MutableStorage()->removeMember("defaultOpenWithLink");
  }


  /**
   * Get the value of the '<code>defaultOpenWithLink</code>' attribute.
   */
  const StringPiece get_defaultOpenWithLink() const {
    const Json::Value& v = Storage("defaultOpenWithLink");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>defaultOpenWithLink</code>' attribute.
   *
   * A link to open this file with the user's default app for this file. Only
   * populated when the drive.apps.readonly scope is used.
   *
   * @param[in] value The new value.
   */
  void set_defaultOpenWithLink(const StringPiece& value) {
    *MutableStorage("defaultOpenWithLink") = value.data();
  }

  /**
   * Determine if the '<code>description</code>' attribute was set.
   *
   * @return true if the '<code>description</code>' attribute was set.
   */
  bool has_description() const {
    return Storage().isMember("description");
  }

  /**
   * Clears the '<code>description</code>' attribute.
   */
  void clear_description() {
    MutableStorage()->removeMember("description");
  }


  /**
   * Get the value of the '<code>description</code>' attribute.
   */
  const StringPiece get_description() const {
    const Json::Value& v = Storage("description");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>description</code>' attribute.
   *
   * A short description of the file.
   *
   * @param[in] value The new value.
   */
  void set_description(const StringPiece& value) {
    *MutableStorage("description") = value.data();
  }

  /**
   * Determine if the '<code>downloadUrl</code>' attribute was set.
   *
   * @return true if the '<code>downloadUrl</code>' attribute was set.
   */
  bool has_downloadUrl() const {
    return Storage().isMember("downloadUrl");
  }

  /**
   * Clears the '<code>downloadUrl</code>' attribute.
   */
  void clear_downloadUrl() {
    MutableStorage()->removeMember("downloadUrl");
  }


  /**
   * Get the value of the '<code>downloadUrl</code>' attribute.
   */
  const StringPiece get_downloadUrl() const {
    const Json::Value& v = Storage("downloadUrl");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>downloadUrl</code>' attribute.
   *
   * Short lived download URL for the file. This is only populated for files
   * with content stored in Drive.
   *
   * @param[in] value The new value.
   */
  void set_downloadUrl(const StringPiece& value) {
    *MutableStorage("downloadUrl") = value.data();
  }

  /**
   * Determine if the '<code>editable</code>' attribute was set.
   *
   * @return true if the '<code>editable</code>' attribute was set.
   */
  bool has_editable() const {
    return Storage().isMember("editable");
  }

  /**
   * Clears the '<code>editable</code>' attribute.
   */
  void clear_editable() {
    MutableStorage()->removeMember("editable");
  }


  /**
   * Get the value of the '<code>editable</code>' attribute.
   */
  bool get_editable() const {
    const Json::Value& storage = Storage("editable");
    return client::JsonValueToCppValueHelper<bool>(storage);
  }

  /**
   * Change the '<code>editable</code>' attribute.
   *
   * Whether the file can be edited by the current user.
   *
   * @param[in] value The new value.
   */
  void set_editable(bool value) {
    client::SetJsonValueFromCppValueHelper<bool>(
      value, MutableStorage("editable"));
  }

  /**
   * Determine if the '<code>embedLink</code>' attribute was set.
   *
   * @return true if the '<code>embedLink</code>' attribute was set.
   */
  bool has_embedLink() const {
    return Storage().isMember("embedLink");
  }

  /**
   * Clears the '<code>embedLink</code>' attribute.
   */
  void clear_embedLink() {
    MutableStorage()->removeMember("embedLink");
  }


  /**
   * Get the value of the '<code>embedLink</code>' attribute.
   */
  const StringPiece get_embedLink() const {
    const Json::Value& v = Storage("embedLink");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>embedLink</code>' attribute.
   *
   * A link for embedding the file.
   *
   * @param[in] value The new value.
   */
  void set_embedLink(const StringPiece& value) {
    *MutableStorage("embedLink") = value.data();
  }

  /**
   * Determine if the '<code>etag</code>' attribute was set.
   *
   * @return true if the '<code>etag</code>' attribute was set.
   */
  bool has_etag() const {
    return Storage().isMember("etag");
  }

  /**
   * Clears the '<code>etag</code>' attribute.
   */
  void clear_etag() {
    MutableStorage()->removeMember("etag");
  }


  /**
   * Get the value of the '<code>etag</code>' attribute.
   */
  const StringPiece get_etag() const {
    const Json::Value& v = Storage("etag");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>etag</code>' attribute.
   *
   * ETag of the file.
   *
   * @param[in] value The new value.
   */
  void set_etag(const StringPiece& value) {
    *MutableStorage("etag") = value.data();
  }

  /**
   * Determine if the '<code>explicitlyTrashed</code>' attribute was set.
   *
   * @return true if the '<code>explicitlyTrashed</code>' attribute was set.
   */
  bool has_explicitlyTrashed() const {
    return Storage().isMember("explicitlyTrashed");
  }

  /**
   * Clears the '<code>explicitlyTrashed</code>' attribute.
   */
  void clear_explicitlyTrashed() {
    MutableStorage()->removeMember("explicitlyTrashed");
  }


  /**
   * Get the value of the '<code>explicitlyTrashed</code>' attribute.
   */
  bool get_explicitlyTrashed() const {
    const Json::Value& storage = Storage("explicitlyTrashed");
    return client::JsonValueToCppValueHelper<bool>(storage);
  }

  /**
   * Change the '<code>explicitlyTrashed</code>' attribute.
   *
   * Whether this file has been explicitly trashed, as opposed to recursively
   * trashed. This will only be populated if the file is trashed.
   *
   * @param[in] value The new value.
   */
  void set_explicitlyTrashed(bool value) {
    client::SetJsonValueFromCppValueHelper<bool>(
      value, MutableStorage("explicitlyTrashed"));
  }

  /**
   * Determine if the '<code>exportLinks</code>' attribute was set.
   *
   * @return true if the '<code>exportLinks</code>' attribute was set.
   */
  bool has_exportLinks() const {
    return Storage().isMember("exportLinks");
  }

  /**
   * Clears the '<code>exportLinks</code>' attribute.
   */
  void clear_exportLinks() {
    MutableStorage()->removeMember("exportLinks");
  }


  /**
   * Get a reference to the value of the '<code>exportLinks</code>' attribute.
   */
  const client::JsonCppAssociativeArray<string > get_exportLinks() const {
    return client::JsonCppAssociativeArray<string >(Storage("exportLinks"));
  }

  /**
   * Gets a reference to a mutable value of the '<code>exportLinks</code>'
   * property.
   *
   * Links for exporting Google Docs to specific formats.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppAssociativeArray<string > mutable_exportLinks() {
    return client::JsonCppAssociativeArray<string >(MutableStorage("exportLinks"));
  }

  /**
   * Determine if the '<code>fileExtension</code>' attribute was set.
   *
   * @return true if the '<code>fileExtension</code>' attribute was set.
   */
  bool has_fileExtension() const {
    return Storage().isMember("fileExtension");
  }

  /**
   * Clears the '<code>fileExtension</code>' attribute.
   */
  void clear_fileExtension() {
    MutableStorage()->removeMember("fileExtension");
  }


  /**
   * Get the value of the '<code>fileExtension</code>' attribute.
   */
  const StringPiece get_fileExtension() const {
    const Json::Value& v = Storage("fileExtension");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>fileExtension</code>' attribute.
   *
   * The file extension used when downloading this file. This field is read
   * only. To set the extension, include it in the title when creating the file.
   * This is only populated for files with content stored in Drive.
   *
   * @param[in] value The new value.
   */
  void set_fileExtension(const StringPiece& value) {
    *MutableStorage("fileExtension") = value.data();
  }

  /**
   * Determine if the '<code>fileSize</code>' attribute was set.
   *
   * @return true if the '<code>fileSize</code>' attribute was set.
   */
  bool has_fileSize() const {
    return Storage().isMember("fileSize");
  }

  /**
   * Clears the '<code>fileSize</code>' attribute.
   */
  void clear_fileSize() {
    MutableStorage()->removeMember("fileSize");
  }


  /**
   * Get the value of the '<code>fileSize</code>' attribute.
   */
  int64 get_fileSize() const {
    const Json::Value& storage = Storage("fileSize");
    return client::JsonValueToCppValueHelper<int64>(storage);
  }

  /**
   * Change the '<code>fileSize</code>' attribute.
   *
   * The size of the file in bytes. This is only populated for files with
   * content stored in Drive.
   *
   * @param[in] value The new value.
   */
  void set_fileSize(int64 value) {
    client::SetJsonValueFromCppValueHelper<int64>(
      value, MutableStorage("fileSize"));
  }

  /**
   * Determine if the '<code>headRevisionId</code>' attribute was set.
   *
   * @return true if the '<code>headRevisionId</code>' attribute was set.
   */
  bool has_headRevisionId() const {
    return Storage().isMember("headRevisionId");
  }

  /**
   * Clears the '<code>headRevisionId</code>' attribute.
   */
  void clear_headRevisionId() {
    MutableStorage()->removeMember("headRevisionId");
  }


  /**
   * Get the value of the '<code>headRevisionId</code>' attribute.
   */
  const StringPiece get_headRevisionId() const {
    const Json::Value& v = Storage("headRevisionId");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>headRevisionId</code>' attribute.
   *
   * The ID of the file's head revision. This will only be populated for files
   * with content stored in Drive.
   *
   * @param[in] value The new value.
   */
  void set_headRevisionId(const StringPiece& value) {
    *MutableStorage("headRevisionId") = value.data();
  }

  /**
   * Determine if the '<code>iconLink</code>' attribute was set.
   *
   * @return true if the '<code>iconLink</code>' attribute was set.
   */
  bool has_iconLink() const {
    return Storage().isMember("iconLink");
  }

  /**
   * Clears the '<code>iconLink</code>' attribute.
   */
  void clear_iconLink() {
    MutableStorage()->removeMember("iconLink");
  }


  /**
   * Get the value of the '<code>iconLink</code>' attribute.
   */
  const StringPiece get_iconLink() const {
    const Json::Value& v = Storage("iconLink");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>iconLink</code>' attribute.
   *
   * A link to the file's icon.
   *
   * @param[in] value The new value.
   */
  void set_iconLink(const StringPiece& value) {
    *MutableStorage("iconLink") = value.data();
  }

  /**
   * Determine if the '<code>id</code>' attribute was set.
   *
   * @return true if the '<code>id</code>' attribute was set.
   */
  bool has_id() const {
    return Storage().isMember("id");
  }

  /**
   * Clears the '<code>id</code>' attribute.
   */
  void clear_id() {
    MutableStorage()->removeMember("id");
  }


  /**
   * Get the value of the '<code>id</code>' attribute.
   */
  const StringPiece get_id() const {
    const Json::Value& v = Storage("id");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>id</code>' attribute.
   *
   * The ID of the file.
   *
   * @param[in] value The new value.
   */
  void set_id(const StringPiece& value) {
    *MutableStorage("id") = value.data();
  }

  /**
   * Determine if the '<code>imageMediaMetadata</code>' attribute was set.
   *
   * @return true if the '<code>imageMediaMetadata</code>' attribute was set.
   */
  bool has_imageMediaMetadata() const {
    return Storage().isMember("imageMediaMetadata");
  }

  /**
   * Clears the '<code>imageMediaMetadata</code>' attribute.
   */
  void clear_imageMediaMetadata() {
    MutableStorage()->removeMember("imageMediaMetadata");
  }


  /**
   * Get a reference to the value of the '<code>imageMediaMetadata</code>'
   * attribute.
   */
  const FileImageMediaMetadata get_imageMediaMetadata() const {
    return FileImageMediaMetadata(Storage("imageMediaMetadata"));
  }

  /**
   * Gets a reference to a mutable value of the
   * '<code>imageMediaMetadata</code>' property.
   *
   * Metadata about image media. This will only be present for image types, and
   * its contents will depend on what can be parsed from the image content.
   *
   * @return The result can be modified to change the attribute value.
   */
  FileImageMediaMetadata mutable_imageMediaMetadata() {
    return FileImageMediaMetadata(MutableStorage("imageMediaMetadata"));
  }

  /**
   * Determine if the '<code>indexableText</code>' attribute was set.
   *
   * @return true if the '<code>indexableText</code>' attribute was set.
   */
  bool has_indexableText() const {
    return Storage().isMember("indexableText");
  }

  /**
   * Clears the '<code>indexableText</code>' attribute.
   */
  void clear_indexableText() {
    MutableStorage()->removeMember("indexableText");
  }


  /**
   * Get a reference to the value of the '<code>indexableText</code>' attribute.
   */
  const FileIndexableText get_indexableText() const {
    return FileIndexableText(Storage("indexableText"));
  }

  /**
   * Gets a reference to a mutable value of the '<code>indexableText</code>'
   * property.
   *
   * Indexable text attributes for the file (can only be written).
   *
   * @return The result can be modified to change the attribute value.
   */
  FileIndexableText mutable_indexableText() {
    return FileIndexableText(MutableStorage("indexableText"));
  }

  /**
   * Determine if the '<code>kind</code>' attribute was set.
   *
   * @return true if the '<code>kind</code>' attribute was set.
   */
  bool has_kind() const {
    return Storage().isMember("kind");
  }

  /**
   * Clears the '<code>kind</code>' attribute.
   */
  void clear_kind() {
    MutableStorage()->removeMember("kind");
  }


  /**
   * Get the value of the '<code>kind</code>' attribute.
   */
  const StringPiece get_kind() const {
    const Json::Value& v = Storage("kind");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>kind</code>' attribute.
   *
   * The type of file. This is always drive#file.
   *
   * @param[in] value The new value.
   */
  void set_kind(const StringPiece& value) {
    *MutableStorage("kind") = value.data();
  }

  /**
   * Determine if the '<code>labels</code>' attribute was set.
   *
   * @return true if the '<code>labels</code>' attribute was set.
   */
  bool has_labels() const {
    return Storage().isMember("labels");
  }

  /**
   * Clears the '<code>labels</code>' attribute.
   */
  void clear_labels() {
    MutableStorage()->removeMember("labels");
  }


  /**
   * Get a reference to the value of the '<code>labels</code>' attribute.
   */
  const FileLabels get_labels() const {
    return FileLabels(Storage("labels"));
  }

  /**
   * Gets a reference to a mutable value of the '<code>labels</code>' property.
   *
   * A group of labels for the file.
   *
   * @return The result can be modified to change the attribute value.
   */
  FileLabels mutable_labels() {
    return FileLabels(MutableStorage("labels"));
  }

  /**
   * Determine if the '<code>lastModifyingUser</code>' attribute was set.
   *
   * @return true if the '<code>lastModifyingUser</code>' attribute was set.
   */
  bool has_lastModifyingUser() const {
    return Storage().isMember("lastModifyingUser");
  }

  /**
   * Clears the '<code>lastModifyingUser</code>' attribute.
   */
  void clear_lastModifyingUser() {
    MutableStorage()->removeMember("lastModifyingUser");
  }


  /**
   * Get a reference to the value of the '<code>lastModifyingUser</code>'
   * attribute.
   */
  const User get_lastModifyingUser() const {
    return User(Storage("lastModifyingUser"));
  }

  /**
   * Gets a reference to a mutable value of the '<code>lastModifyingUser</code>'
   * property.
   *
   * The last user to modify this file.
   *
   * @return The result can be modified to change the attribute value.
   */
  User mutable_lastModifyingUser() {
    return User(MutableStorage("lastModifyingUser"));
  }

  /**
   * Determine if the '<code>lastModifyingUserName</code>' attribute was set.
   *
   * @return true if the '<code>lastModifyingUserName</code>' attribute was set.
   */
  bool has_lastModifyingUserName() const {
    return Storage().isMember("lastModifyingUserName");
  }

  /**
   * Clears the '<code>lastModifyingUserName</code>' attribute.
   */
  void clear_lastModifyingUserName() {
    MutableStorage()->removeMember("lastModifyingUserName");
  }


  /**
   * Get the value of the '<code>lastModifyingUserName</code>' attribute.
   */
  const StringPiece get_lastModifyingUserName() const {
    const Json::Value& v = Storage("lastModifyingUserName");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>lastModifyingUserName</code>' attribute.
   *
   * Name of the last user to modify this file.
   *
   * @param[in] value The new value.
   */
  void set_lastModifyingUserName(const StringPiece& value) {
    *MutableStorage("lastModifyingUserName") = value.data();
  }

  /**
   * Determine if the '<code>lastViewedByMeDate</code>' attribute was set.
   *
   * @return true if the '<code>lastViewedByMeDate</code>' attribute was set.
   */
  bool has_lastViewedByMeDate() const {
    return Storage().isMember("lastViewedByMeDate");
  }

  /**
   * Clears the '<code>lastViewedByMeDate</code>' attribute.
   */
  void clear_lastViewedByMeDate() {
    MutableStorage()->removeMember("lastViewedByMeDate");
  }


  /**
   * Get the value of the '<code>lastViewedByMeDate</code>' attribute.
   */
  client::DateTime get_lastViewedByMeDate() const {
    const Json::Value& storage = Storage("lastViewedByMeDate");
    return client::JsonValueToCppValueHelper<client::DateTime>(storage);
  }

  /**
   * Change the '<code>lastViewedByMeDate</code>' attribute.
   *
   * Last time this file was viewed by the user (formatted RFC 3339 timestamp).
   *
   * @param[in] value The new value.
   */
  void set_lastViewedByMeDate(client::DateTime value) {
    client::SetJsonValueFromCppValueHelper<client::DateTime>(
      value, MutableStorage("lastViewedByMeDate"));
  }

  /**
   * Determine if the '<code>md5Checksum</code>' attribute was set.
   *
   * @return true if the '<code>md5Checksum</code>' attribute was set.
   */
  bool has_md5Checksum() const {
    return Storage().isMember("md5Checksum");
  }

  /**
   * Clears the '<code>md5Checksum</code>' attribute.
   */
  void clear_md5Checksum() {
    MutableStorage()->removeMember("md5Checksum");
  }


  /**
   * Get the value of the '<code>md5Checksum</code>' attribute.
   */
  const StringPiece get_md5Checksum() const {
    const Json::Value& v = Storage("md5Checksum");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>md5Checksum</code>' attribute.
   *
   * An MD5 checksum for the content of this file. This is populated only for
   * files with content stored in Drive.
   *
   * @param[in] value The new value.
   */
  void set_md5Checksum(const StringPiece& value) {
    *MutableStorage("md5Checksum") = value.data();
  }

  /**
   * Determine if the '<code>mimeType</code>' attribute was set.
   *
   * @return true if the '<code>mimeType</code>' attribute was set.
   */
  bool has_mimeType() const {
    return Storage().isMember("mimeType");
  }

  /**
   * Clears the '<code>mimeType</code>' attribute.
   */
  void clear_mimeType() {
    MutableStorage()->removeMember("mimeType");
  }


  /**
   * Get the value of the '<code>mimeType</code>' attribute.
   */
  const StringPiece get_mimeType() const {
    const Json::Value& v = Storage("mimeType");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>mimeType</code>' attribute.
   *
   * The MIME type of the file. This is only mutable on update when uploading
   * new content. This field can be left blank, and the mimetype will be
   * determined from the uploaded content's MIME type.
   *
   * @param[in] value The new value.
   */
  void set_mimeType(const StringPiece& value) {
    *MutableStorage("mimeType") = value.data();
  }

  /**
   * Determine if the '<code>modifiedByMeDate</code>' attribute was set.
   *
   * @return true if the '<code>modifiedByMeDate</code>' attribute was set.
   */
  bool has_modifiedByMeDate() const {
    return Storage().isMember("modifiedByMeDate");
  }

  /**
   * Clears the '<code>modifiedByMeDate</code>' attribute.
   */
  void clear_modifiedByMeDate() {
    MutableStorage()->removeMember("modifiedByMeDate");
  }


  /**
   * Get the value of the '<code>modifiedByMeDate</code>' attribute.
   */
  client::DateTime get_modifiedByMeDate() const {
    const Json::Value& storage = Storage("modifiedByMeDate");
    return client::JsonValueToCppValueHelper<client::DateTime>(storage);
  }

  /**
   * Change the '<code>modifiedByMeDate</code>' attribute.
   *
   * Last time this file was modified by the user (formatted RFC 3339
   * timestamp). Note that setting modifiedDate will also update the
   * modifiedByMe date for the user which set the date.
   *
   * @param[in] value The new value.
   */
  void set_modifiedByMeDate(client::DateTime value) {
    client::SetJsonValueFromCppValueHelper<client::DateTime>(
      value, MutableStorage("modifiedByMeDate"));
  }

  /**
   * Determine if the '<code>modifiedDate</code>' attribute was set.
   *
   * @return true if the '<code>modifiedDate</code>' attribute was set.
   */
  bool has_modifiedDate() const {
    return Storage().isMember("modifiedDate");
  }

  /**
   * Clears the '<code>modifiedDate</code>' attribute.
   */
  void clear_modifiedDate() {
    MutableStorage()->removeMember("modifiedDate");
  }


  /**
   * Get the value of the '<code>modifiedDate</code>' attribute.
   */
  client::DateTime get_modifiedDate() const {
    const Json::Value& storage = Storage("modifiedDate");
    return client::JsonValueToCppValueHelper<client::DateTime>(storage);
  }

  /**
   * Change the '<code>modifiedDate</code>' attribute.
   *
   * Last time this file was modified by anyone (formatted RFC 3339 timestamp).
   * This is only mutable on update when the setModifiedDate parameter is set.
   *
   * @param[in] value The new value.
   */
  void set_modifiedDate(client::DateTime value) {
    client::SetJsonValueFromCppValueHelper<client::DateTime>(
      value, MutableStorage("modifiedDate"));
  }

  /**
   * Determine if the '<code>openWithLinks</code>' attribute was set.
   *
   * @return true if the '<code>openWithLinks</code>' attribute was set.
   */
  bool has_openWithLinks() const {
    return Storage().isMember("openWithLinks");
  }

  /**
   * Clears the '<code>openWithLinks</code>' attribute.
   */
  void clear_openWithLinks() {
    MutableStorage()->removeMember("openWithLinks");
  }


  /**
   * Get a reference to the value of the '<code>openWithLinks</code>' attribute.
   */
  const client::JsonCppAssociativeArray<string > get_openWithLinks() const {
    return client::JsonCppAssociativeArray<string >(Storage("openWithLinks"));
  }

  /**
   * Gets a reference to a mutable value of the '<code>openWithLinks</code>'
   * property.
   *
   * A map of the id of each of the user's apps to a link to open this file with
   * that app. Only populated when the drive.apps.readonly scope is used.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppAssociativeArray<string > mutable_openWithLinks() {
    return client::JsonCppAssociativeArray<string >(MutableStorage("openWithLinks"));
  }

  /**
   * Determine if the '<code>originalFilename</code>' attribute was set.
   *
   * @return true if the '<code>originalFilename</code>' attribute was set.
   */
  bool has_originalFilename() const {
    return Storage().isMember("originalFilename");
  }

  /**
   * Clears the '<code>originalFilename</code>' attribute.
   */
  void clear_originalFilename() {
    MutableStorage()->removeMember("originalFilename");
  }


  /**
   * Get the value of the '<code>originalFilename</code>' attribute.
   */
  const StringPiece get_originalFilename() const {
    const Json::Value& v = Storage("originalFilename");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>originalFilename</code>' attribute.
   *
   * The original filename if the file was uploaded manually, or the original
   * title if the file was inserted through the API. Note that renames of the
   * title will not change the original filename. This will only be populated on
   * files with content stored in Drive.
   *
   * @param[in] value The new value.
   */
  void set_originalFilename(const StringPiece& value) {
    *MutableStorage("originalFilename") = value.data();
  }

  /**
   * Determine if the '<code>ownerNames</code>' attribute was set.
   *
   * @return true if the '<code>ownerNames</code>' attribute was set.
   */
  bool has_ownerNames() const {
    return Storage().isMember("ownerNames");
  }

  /**
   * Clears the '<code>ownerNames</code>' attribute.
   */
  void clear_ownerNames() {
    MutableStorage()->removeMember("ownerNames");
  }


  /**
   * Get a reference to the value of the '<code>ownerNames</code>' attribute.
   */
  const client::JsonCppArray<string > get_ownerNames() const {
    return client::JsonCppArray<string >(Storage("ownerNames"));
  }

  /**
   * Gets a reference to a mutable value of the '<code>ownerNames</code>'
   * property.
   *
   * Name(s) of the owner(s) of this file.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppArray<string > mutable_ownerNames() {
    return client::JsonCppArray<string >(MutableStorage("ownerNames"));
  }

  /**
   * Determine if the '<code>owners</code>' attribute was set.
   *
   * @return true if the '<code>owners</code>' attribute was set.
   */
  bool has_owners() const {
    return Storage().isMember("owners");
  }

  /**
   * Clears the '<code>owners</code>' attribute.
   */
  void clear_owners() {
    MutableStorage()->removeMember("owners");
  }


  /**
   * Get a reference to the value of the '<code>owners</code>' attribute.
   */
  const client::JsonCppArray<User > get_owners() const {
    return client::JsonCppArray<User >(Storage("owners"));
  }

  /**
   * Gets a reference to a mutable value of the '<code>owners</code>' property.
   *
   * The owner(s) of this file.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppArray<User > mutable_owners() {
    return client::JsonCppArray<User >(MutableStorage("owners"));
  }

  /**
   * Determine if the '<code>parents</code>' attribute was set.
   *
   * @return true if the '<code>parents</code>' attribute was set.
   */
  bool has_parents() const {
    return Storage().isMember("parents");
  }

  /**
   * Clears the '<code>parents</code>' attribute.
   */
  void clear_parents() {
    MutableStorage()->removeMember("parents");
  }


  /**
   * Get a reference to the value of the '<code>parents</code>' attribute.
   */
  const client::JsonCppArray<ParentReference > get_parents() const {
    return client::JsonCppArray<ParentReference >(Storage("parents"));
  }

  /**
   * Gets a reference to a mutable value of the '<code>parents</code>' property.
   *
   * Collection of parent folders which contain this file.
   * Setting this field will put the file in all of the provided folders. On
   * insert, if no folders are provided, the file will be placed in the default
   * root folder.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppArray<ParentReference > mutable_parents() {
    return client::JsonCppArray<ParentReference >(MutableStorage("parents"));
  }

  /**
   * Determine if the '<code>properties</code>' attribute was set.
   *
   * @return true if the '<code>properties</code>' attribute was set.
   */
  bool has_properties() const {
    return Storage().isMember("properties");
  }

  /**
   * Clears the '<code>properties</code>' attribute.
   */
  void clear_properties() {
    MutableStorage()->removeMember("properties");
  }


  /**
   * Get a reference to the value of the '<code>properties</code>' attribute.
   */
  const client::JsonCppArray<Property > get_properties() const {
    return client::JsonCppArray<Property >(Storage("properties"));
  }

  /**
   * Gets a reference to a mutable value of the '<code>properties</code>'
   * property.
   *
   * The list of properties.
   *
   * @return The result can be modified to change the attribute value.
   */
  client::JsonCppArray<Property > mutable_properties() {
    return client::JsonCppArray<Property >(MutableStorage("properties"));
  }

  /**
   * Determine if the '<code>quotaBytesUsed</code>' attribute was set.
   *
   * @return true if the '<code>quotaBytesUsed</code>' attribute was set.
   */
  bool has_quotaBytesUsed() const {
    return Storage().isMember("quotaBytesUsed");
  }

  /**
   * Clears the '<code>quotaBytesUsed</code>' attribute.
   */
  void clear_quotaBytesUsed() {
    MutableStorage()->removeMember("quotaBytesUsed");
  }


  /**
   * Get the value of the '<code>quotaBytesUsed</code>' attribute.
   */
  int64 get_quotaBytesUsed() const {
    const Json::Value& storage = Storage("quotaBytesUsed");
    return client::JsonValueToCppValueHelper<int64>(storage);
  }

  /**
   * Change the '<code>quotaBytesUsed</code>' attribute.
   *
   * The number of quota bytes used by this file.
   *
   * @param[in] value The new value.
   */
  void set_quotaBytesUsed(int64 value) {
    client::SetJsonValueFromCppValueHelper<int64>(
      value, MutableStorage("quotaBytesUsed"));
  }

  /**
   * Determine if the '<code>selfLink</code>' attribute was set.
   *
   * @return true if the '<code>selfLink</code>' attribute was set.
   */
  bool has_selfLink() const {
    return Storage().isMember("selfLink");
  }

  /**
   * Clears the '<code>selfLink</code>' attribute.
   */
  void clear_selfLink() {
    MutableStorage()->removeMember("selfLink");
  }


  /**
   * Get the value of the '<code>selfLink</code>' attribute.
   */
  const StringPiece get_selfLink() const {
    const Json::Value& v = Storage("selfLink");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>selfLink</code>' attribute.
   *
   * A link back to this file.
   *
   * @param[in] value The new value.
   */
  void set_selfLink(const StringPiece& value) {
    *MutableStorage("selfLink") = value.data();
  }

  /**
   * Determine if the '<code>shared</code>' attribute was set.
   *
   * @return true if the '<code>shared</code>' attribute was set.
   */
  bool has_shared() const {
    return Storage().isMember("shared");
  }

  /**
   * Clears the '<code>shared</code>' attribute.
   */
  void clear_shared() {
    MutableStorage()->removeMember("shared");
  }


  /**
   * Get the value of the '<code>shared</code>' attribute.
   */
  bool get_shared() const {
    const Json::Value& storage = Storage("shared");
    return client::JsonValueToCppValueHelper<bool>(storage);
  }

  /**
   * Change the '<code>shared</code>' attribute.
   *
   * Whether the file has been shared.
   *
   * @param[in] value The new value.
   */
  void set_shared(bool value) {
    client::SetJsonValueFromCppValueHelper<bool>(
      value, MutableStorage("shared"));
  }

  /**
   * Determine if the '<code>sharedWithMeDate</code>' attribute was set.
   *
   * @return true if the '<code>sharedWithMeDate</code>' attribute was set.
   */
  bool has_sharedWithMeDate() const {
    return Storage().isMember("sharedWithMeDate");
  }

  /**
   * Clears the '<code>sharedWithMeDate</code>' attribute.
   */
  void clear_sharedWithMeDate() {
    MutableStorage()->removeMember("sharedWithMeDate");
  }


  /**
   * Get the value of the '<code>sharedWithMeDate</code>' attribute.
   */
  client::DateTime get_sharedWithMeDate() const {
    const Json::Value& storage = Storage("sharedWithMeDate");
    return client::JsonValueToCppValueHelper<client::DateTime>(storage);
  }

  /**
   * Change the '<code>sharedWithMeDate</code>' attribute.
   *
   * Time at which this file was shared with the user (formatted RFC 3339
   * timestamp).
   *
   * @param[in] value The new value.
   */
  void set_sharedWithMeDate(client::DateTime value) {
    client::SetJsonValueFromCppValueHelper<client::DateTime>(
      value, MutableStorage("sharedWithMeDate"));
  }

  /**
   * Determine if the '<code>thumbnail</code>' attribute was set.
   *
   * @return true if the '<code>thumbnail</code>' attribute was set.
   */
  bool has_thumbnail() const {
    return Storage().isMember("thumbnail");
  }

  /**
   * Clears the '<code>thumbnail</code>' attribute.
   */
  void clear_thumbnail() {
    MutableStorage()->removeMember("thumbnail");
  }


  /**
   * Get a reference to the value of the '<code>thumbnail</code>' attribute.
   */
  const FileThumbnail get_thumbnail() const {
    return FileThumbnail(Storage("thumbnail"));
  }

  /**
   * Gets a reference to a mutable value of the '<code>thumbnail</code>'
   * property.
   *
   * Thumbnail for the file. Only accepted on upload and for files that are not
   * already thumbnailed by Google.
   *
   * @return The result can be modified to change the attribute value.
   */
  FileThumbnail mutable_thumbnail() {
    return FileThumbnail(MutableStorage("thumbnail"));
  }

  /**
   * Determine if the '<code>thumbnailLink</code>' attribute was set.
   *
   * @return true if the '<code>thumbnailLink</code>' attribute was set.
   */
  bool has_thumbnailLink() const {
    return Storage().isMember("thumbnailLink");
  }

  /**
   * Clears the '<code>thumbnailLink</code>' attribute.
   */
  void clear_thumbnailLink() {
    MutableStorage()->removeMember("thumbnailLink");
  }


  /**
   * Get the value of the '<code>thumbnailLink</code>' attribute.
   */
  const StringPiece get_thumbnailLink() const {
    const Json::Value& v = Storage("thumbnailLink");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>thumbnailLink</code>' attribute.
   *
   * A link to the file's thumbnail.
   *
   * @param[in] value The new value.
   */
  void set_thumbnailLink(const StringPiece& value) {
    *MutableStorage("thumbnailLink") = value.data();
  }

  /**
   * Determine if the '<code>title</code>' attribute was set.
   *
   * @return true if the '<code>title</code>' attribute was set.
   */
  bool has_title() const {
    return Storage().isMember("title");
  }

  /**
   * Clears the '<code>title</code>' attribute.
   */
  void clear_title() {
    MutableStorage()->removeMember("title");
  }


  /**
   * Get the value of the '<code>title</code>' attribute.
   */
  const StringPiece get_title() const {
    const Json::Value& v = Storage("title");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>title</code>' attribute.
   *
   * The title of this file.
   *
   * @param[in] value The new value.
   */
  void set_title(const StringPiece& value) {
    *MutableStorage("title") = value.data();
  }

  /**
   * Determine if the '<code>userPermission</code>' attribute was set.
   *
   * @return true if the '<code>userPermission</code>' attribute was set.
   */
  bool has_userPermission() const {
    return Storage().isMember("userPermission");
  }

  /**
   * Clears the '<code>userPermission</code>' attribute.
   */
  void clear_userPermission() {
    MutableStorage()->removeMember("userPermission");
  }


  /**
   * Get a reference to the value of the '<code>userPermission</code>'
   * attribute.
   */
  const Permission get_userPermission() const {
    return Permission(Storage("userPermission"));
  }

  /**
   * Gets a reference to a mutable value of the '<code>userPermission</code>'
   * property.
   *
   * The permissions for the authenticated user on this file.
   *
   * @return The result can be modified to change the attribute value.
   */
  Permission mutable_userPermission() {
    return Permission(MutableStorage("userPermission"));
  }

  /**
   * Determine if the '<code>webContentLink</code>' attribute was set.
   *
   * @return true if the '<code>webContentLink</code>' attribute was set.
   */
  bool has_webContentLink() const {
    return Storage().isMember("webContentLink");
  }

  /**
   * Clears the '<code>webContentLink</code>' attribute.
   */
  void clear_webContentLink() {
    MutableStorage()->removeMember("webContentLink");
  }


  /**
   * Get the value of the '<code>webContentLink</code>' attribute.
   */
  const StringPiece get_webContentLink() const {
    const Json::Value& v = Storage("webContentLink");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>webContentLink</code>' attribute.
   *
   * A link for downloading the content of the file in a browser using cookie
   * based authentication. In cases where the content is shared publicly, the
   * content can be downloaded without any credentials.
   *
   * @param[in] value The new value.
   */
  void set_webContentLink(const StringPiece& value) {
    *MutableStorage("webContentLink") = value.data();
  }

  /**
   * Determine if the '<code>webViewLink</code>' attribute was set.
   *
   * @return true if the '<code>webViewLink</code>' attribute was set.
   */
  bool has_webViewLink() const {
    return Storage().isMember("webViewLink");
  }

  /**
   * Clears the '<code>webViewLink</code>' attribute.
   */
  void clear_webViewLink() {
    MutableStorage()->removeMember("webViewLink");
  }


  /**
   * Get the value of the '<code>webViewLink</code>' attribute.
   */
  const StringPiece get_webViewLink() const {
    const Json::Value& v = Storage("webViewLink");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>webViewLink</code>' attribute.
   *
   * A link only available on public folders for viewing their static web assets
   * (HTML, CSS, JS, etc) via Google Drive's Website Hosting.
   *
   * @param[in] value The new value.
   */
  void set_webViewLink(const StringPiece& value) {
    *MutableStorage("webViewLink") = value.data();
  }

  /**
   * Determine if the '<code>writersCanShare</code>' attribute was set.
   *
   * @return true if the '<code>writersCanShare</code>' attribute was set.
   */
  bool has_writersCanShare() const {
    return Storage().isMember("writersCanShare");
  }

  /**
   * Clears the '<code>writersCanShare</code>' attribute.
   */
  void clear_writersCanShare() {
    MutableStorage()->removeMember("writersCanShare");
  }


  /**
   * Get the value of the '<code>writersCanShare</code>' attribute.
   */
  bool get_writersCanShare() const {
    const Json::Value& storage = Storage("writersCanShare");
    return client::JsonValueToCppValueHelper<bool>(storage);
  }

  /**
   * Change the '<code>writersCanShare</code>' attribute.
   *
   * Whether writers can share the document with other users.
   *
   * @param[in] value The new value.
   */
  void set_writersCanShare(bool value) {
    client::SetJsonValueFromCppValueHelper<bool>(
      value, MutableStorage("writersCanShare"));
  }

 private:
  void operator=(const File&);
};  // File
}  // namespace google_drive_api
#endif  // GOOGLE_DRIVE_API_FILE_H_
